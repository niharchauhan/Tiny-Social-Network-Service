// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: synchronizer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_synchronizer_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_synchronizer_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_synchronizer_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_synchronizer_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_synchronizer_2eproto;
namespace csce438 {
class AllUsers;
struct AllUsersDefaultTypeInternal;
extern AllUsersDefaultTypeInternal _AllUsers_default_instance_;
class GetAllUsersRequest;
struct GetAllUsersRequestDefaultTypeInternal;
extern GetAllUsersRequestDefaultTypeInternal _GetAllUsersRequest_default_instance_;
class GetFLRequest;
struct GetFLRequestDefaultTypeInternal;
extern GetFLRequestDefaultTypeInternal _GetFLRequest_default_instance_;
class GetFLResponse;
struct GetFLResponseDefaultTypeInternal;
extern GetFLResponseDefaultTypeInternal _GetFLResponse_default_instance_;
class GetTLRequest;
struct GetTLRequestDefaultTypeInternal;
extern GetTLRequestDefaultTypeInternal _GetTLRequest_default_instance_;
class GetTLResponse;
struct GetTLResponseDefaultTypeInternal;
extern GetTLResponseDefaultTypeInternal _GetTLResponse_default_instance_;
class ResynchServerRequest;
struct ResynchServerRequestDefaultTypeInternal;
extern ResynchServerRequestDefaultTypeInternal _ResynchServerRequest_default_instance_;
class ResynchServerResponse;
struct ResynchServerResponseDefaultTypeInternal;
extern ResynchServerResponseDefaultTypeInternal _ResynchServerResponse_default_instance_;
}  // namespace csce438
PROTOBUF_NAMESPACE_OPEN
template <>
::csce438::AllUsers* Arena::CreateMaybeMessage<::csce438::AllUsers>(Arena*);
template <>
::csce438::GetAllUsersRequest* Arena::CreateMaybeMessage<::csce438::GetAllUsersRequest>(Arena*);
template <>
::csce438::GetFLRequest* Arena::CreateMaybeMessage<::csce438::GetFLRequest>(Arena*);
template <>
::csce438::GetFLResponse* Arena::CreateMaybeMessage<::csce438::GetFLResponse>(Arena*);
template <>
::csce438::GetTLRequest* Arena::CreateMaybeMessage<::csce438::GetTLRequest>(Arena*);
template <>
::csce438::GetTLResponse* Arena::CreateMaybeMessage<::csce438::GetTLResponse>(Arena*);
template <>
::csce438::ResynchServerRequest* Arena::CreateMaybeMessage<::csce438::ResynchServerRequest>(Arena*);
template <>
::csce438::ResynchServerResponse* Arena::CreateMaybeMessage<::csce438::ResynchServerResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace csce438 {

// ===================================================================


// -------------------------------------------------------------------

class GetAllUsersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csce438.GetAllUsersRequest) */ {
 public:
  inline GetAllUsersRequest() : GetAllUsersRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAllUsersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllUsersRequest(const GetAllUsersRequest& from);
  GetAllUsersRequest(GetAllUsersRequest&& from) noexcept
    : GetAllUsersRequest() {
    *this = ::std::move(from);
  }

  inline GetAllUsersRequest& operator=(const GetAllUsersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllUsersRequest& operator=(GetAllUsersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllUsersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllUsersRequest* internal_default_instance() {
    return reinterpret_cast<const GetAllUsersRequest*>(
               &_GetAllUsersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetAllUsersRequest& a, GetAllUsersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllUsersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllUsersRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllUsersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllUsersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetAllUsersRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetAllUsersRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csce438.GetAllUsersRequest";
  }
  protected:
  explicit GetAllUsersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csce438.GetAllUsersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_synchronizer_2eproto;
};// -------------------------------------------------------------------

class AllUsers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.AllUsers) */ {
 public:
  inline AllUsers() : AllUsers(nullptr) {}
  ~AllUsers() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllUsers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AllUsers(const AllUsers& from);
  AllUsers(AllUsers&& from) noexcept
    : AllUsers() {
    *this = ::std::move(from);
  }

  inline AllUsers& operator=(const AllUsers& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllUsers& operator=(AllUsers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllUsers& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllUsers* internal_default_instance() {
    return reinterpret_cast<const AllUsers*>(
               &_AllUsers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AllUsers& a, AllUsers& b) {
    a.Swap(&b);
  }
  inline void Swap(AllUsers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllUsers* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllUsers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllUsers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AllUsers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AllUsers& from) {
    AllUsers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllUsers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csce438.AllUsers";
  }
  protected:
  explicit AllUsers(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllUsersFieldNumber = 1,
  };
  // repeated string allUsers = 1;
  int allusers_size() const;
  private:
  int _internal_allusers_size() const;

  public:
  void clear_allusers() ;
  const std::string& allusers(int index) const;
  std::string* mutable_allusers(int index);
  void set_allusers(int index, const std::string& value);
  void set_allusers(int index, std::string&& value);
  void set_allusers(int index, const char* value);
  void set_allusers(int index, const char* value, std::size_t size);
  void set_allusers(int index, absl::string_view value);
  std::string* add_allusers();
  void add_allusers(const std::string& value);
  void add_allusers(std::string&& value);
  void add_allusers(const char* value);
  void add_allusers(const char* value, std::size_t size);
  void add_allusers(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& allusers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_allusers();

  private:
  const std::string& _internal_allusers(int index) const;
  std::string* _internal_add_allusers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_allusers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_allusers();

  public:
  // @@protoc_insertion_point(class_scope:csce438.AllUsers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> allusers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_synchronizer_2eproto;
};// -------------------------------------------------------------------

class GetFLRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csce438.GetFLRequest) */ {
 public:
  inline GetFLRequest() : GetFLRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFLRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFLRequest(const GetFLRequest& from);
  GetFLRequest(GetFLRequest&& from) noexcept
    : GetFLRequest() {
    *this = ::std::move(from);
  }

  inline GetFLRequest& operator=(const GetFLRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFLRequest& operator=(GetFLRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFLRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFLRequest* internal_default_instance() {
    return reinterpret_cast<const GetFLRequest*>(
               &_GetFLRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetFLRequest& a, GetFLRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFLRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFLRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFLRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFLRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetFLRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetFLRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csce438.GetFLRequest";
  }
  protected:
  explicit GetFLRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csce438.GetFLRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_synchronizer_2eproto;
};// -------------------------------------------------------------------

class GetFLResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.GetFLResponse) */ {
 public:
  inline GetFLResponse() : GetFLResponse(nullptr) {}
  ~GetFLResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetFLResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFLResponse(const GetFLResponse& from);
  GetFLResponse(GetFLResponse&& from) noexcept
    : GetFLResponse() {
    *this = ::std::move(from);
  }

  inline GetFLResponse& operator=(const GetFLResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFLResponse& operator=(GetFLResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFLResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFLResponse* internal_default_instance() {
    return reinterpret_cast<const GetFLResponse*>(
               &_GetFLResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetFLResponse& a, GetFLResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFLResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFLResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFLResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFLResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFLResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetFLResponse& from) {
    GetFLResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFLResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csce438.GetFLResponse";
  }
  protected:
  explicit GetFLResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinesFieldNumber = 1,
  };
  // repeated string lines = 1;
  int lines_size() const;
  private:
  int _internal_lines_size() const;

  public:
  void clear_lines() ;
  const std::string& lines(int index) const;
  std::string* mutable_lines(int index);
  void set_lines(int index, const std::string& value);
  void set_lines(int index, std::string&& value);
  void set_lines(int index, const char* value);
  void set_lines(int index, const char* value, std::size_t size);
  void set_lines(int index, absl::string_view value);
  std::string* add_lines();
  void add_lines(const std::string& value);
  void add_lines(std::string&& value);
  void add_lines(const char* value);
  void add_lines(const char* value, std::size_t size);
  void add_lines(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lines() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lines();

  private:
  const std::string& _internal_lines(int index) const;
  std::string* _internal_add_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_lines() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_lines();

  public:
  // @@protoc_insertion_point(class_scope:csce438.GetFLResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lines_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_synchronizer_2eproto;
};// -------------------------------------------------------------------

class GetTLRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.GetTLRequest) */ {
 public:
  inline GetTLRequest() : GetTLRequest(nullptr) {}
  ~GetTLRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTLRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTLRequest(const GetTLRequest& from);
  GetTLRequest(GetTLRequest&& from) noexcept
    : GetTLRequest() {
    *this = ::std::move(from);
  }

  inline GetTLRequest& operator=(const GetTLRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTLRequest& operator=(GetTLRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTLRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTLRequest* internal_default_instance() {
    return reinterpret_cast<const GetTLRequest*>(
               &_GetTLRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetTLRequest& a, GetTLRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTLRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTLRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTLRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTLRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTLRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTLRequest& from) {
    GetTLRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTLRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csce438.GetTLRequest";
  }
  protected:
  explicit GetTLRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // int32 uid = 1;
  void clear_uid() ;
  ::int32_t uid() const;
  void set_uid(::int32_t value);

  private:
  ::int32_t _internal_uid() const;
  void _internal_set_uid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:csce438.GetTLRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_synchronizer_2eproto;
};// -------------------------------------------------------------------

class GetTLResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.GetTLResponse) */ {
 public:
  inline GetTLResponse() : GetTLResponse(nullptr) {}
  ~GetTLResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTLResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTLResponse(const GetTLResponse& from);
  GetTLResponse(GetTLResponse&& from) noexcept
    : GetTLResponse() {
    *this = ::std::move(from);
  }

  inline GetTLResponse& operator=(const GetTLResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTLResponse& operator=(GetTLResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTLResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTLResponse* internal_default_instance() {
    return reinterpret_cast<const GetTLResponse*>(
               &_GetTLResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetTLResponse& a, GetTLResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTLResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTLResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTLResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTLResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTLResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTLResponse& from) {
    GetTLResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTLResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csce438.GetTLResponse";
  }
  protected:
  explicit GetTLResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinesFieldNumber = 1,
  };
  // repeated string lines = 1;
  int lines_size() const;
  private:
  int _internal_lines_size() const;

  public:
  void clear_lines() ;
  const std::string& lines(int index) const;
  std::string* mutable_lines(int index);
  void set_lines(int index, const std::string& value);
  void set_lines(int index, std::string&& value);
  void set_lines(int index, const char* value);
  void set_lines(int index, const char* value, std::size_t size);
  void set_lines(int index, absl::string_view value);
  std::string* add_lines();
  void add_lines(const std::string& value);
  void add_lines(std::string&& value);
  void add_lines(const char* value);
  void add_lines(const char* value, std::size_t size);
  void add_lines(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lines() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lines();

  private:
  const std::string& _internal_lines(int index) const;
  std::string* _internal_add_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_lines() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_lines();

  public:
  // @@protoc_insertion_point(class_scope:csce438.GetTLResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lines_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_synchronizer_2eproto;
};// -------------------------------------------------------------------

class ResynchServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.ResynchServerRequest) */ {
 public:
  inline ResynchServerRequest() : ResynchServerRequest(nullptr) {}
  ~ResynchServerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResynchServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResynchServerRequest(const ResynchServerRequest& from);
  ResynchServerRequest(ResynchServerRequest&& from) noexcept
    : ResynchServerRequest() {
    *this = ::std::move(from);
  }

  inline ResynchServerRequest& operator=(const ResynchServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResynchServerRequest& operator=(ResynchServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResynchServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResynchServerRequest* internal_default_instance() {
    return reinterpret_cast<const ResynchServerRequest*>(
               &_ResynchServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ResynchServerRequest& a, ResynchServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResynchServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResynchServerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResynchServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResynchServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResynchServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResynchServerRequest& from) {
    ResynchServerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResynchServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csce438.ResynchServerRequest";
  }
  protected:
  explicit ResynchServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerIDFieldNumber = 1,
  };
  // int32 serverID = 1;
  void clear_serverid() ;
  ::int32_t serverid() const;
  void set_serverid(::int32_t value);

  private:
  ::int32_t _internal_serverid() const;
  void _internal_set_serverid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:csce438.ResynchServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t serverid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_synchronizer_2eproto;
};// -------------------------------------------------------------------

class ResynchServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csce438.ResynchServerResponse) */ {
 public:
  inline ResynchServerResponse() : ResynchServerResponse(nullptr) {}
  ~ResynchServerResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResynchServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResynchServerResponse(const ResynchServerResponse& from);
  ResynchServerResponse(ResynchServerResponse&& from) noexcept
    : ResynchServerResponse() {
    *this = ::std::move(from);
  }

  inline ResynchServerResponse& operator=(const ResynchServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResynchServerResponse& operator=(ResynchServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResynchServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResynchServerResponse* internal_default_instance() {
    return reinterpret_cast<const ResynchServerResponse*>(
               &_ResynchServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ResynchServerResponse& a, ResynchServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResynchServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResynchServerResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResynchServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResynchServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResynchServerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResynchServerResponse& from) {
    ResynchServerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResynchServerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csce438.ResynchServerResponse";
  }
  protected:
  explicit ResynchServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // string Status = 1;
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:csce438.ResynchServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_synchronizer_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetAllUsersRequest

// -------------------------------------------------------------------

// AllUsers

// repeated string allUsers = 1;
inline int AllUsers::_internal_allusers_size() const {
  return _impl_.allusers_.size();
}
inline int AllUsers::allusers_size() const {
  return _internal_allusers_size();
}
inline void AllUsers::clear_allusers() {
  _internal_mutable_allusers()->Clear();
}
inline std::string* AllUsers::add_allusers() {
  std::string* _s = _internal_add_allusers();
  // @@protoc_insertion_point(field_add_mutable:csce438.AllUsers.allUsers)
  return _s;
}
inline const std::string& AllUsers::allusers(int index) const {
  // @@protoc_insertion_point(field_get:csce438.AllUsers.allUsers)
  return _internal_allusers(index);
}
inline std::string* AllUsers::mutable_allusers(int index) {
  // @@protoc_insertion_point(field_mutable:csce438.AllUsers.allUsers)
  return _internal_mutable_allusers()->Mutable(index);
}
inline void AllUsers::set_allusers(int index, const std::string& value) {
  _internal_mutable_allusers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csce438.AllUsers.allUsers)
}
inline void AllUsers::set_allusers(int index, std::string&& value) {
  _internal_mutable_allusers()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csce438.AllUsers.allUsers)
}
inline void AllUsers::set_allusers(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_allusers()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csce438.AllUsers.allUsers)
}
inline void AllUsers::set_allusers(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_allusers()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csce438.AllUsers.allUsers)
}
inline void AllUsers::set_allusers(int index, absl::string_view value) {
  _internal_mutable_allusers()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csce438.AllUsers.allUsers)
}
inline void AllUsers::add_allusers(const std::string& value) {
  _internal_mutable_allusers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csce438.AllUsers.allUsers)
}
inline void AllUsers::add_allusers(std::string&& value) {
  _internal_mutable_allusers()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csce438.AllUsers.allUsers)
}
inline void AllUsers::add_allusers(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_allusers()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csce438.AllUsers.allUsers)
}
inline void AllUsers::add_allusers(const char* value, std::size_t size) {
  _internal_mutable_allusers()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csce438.AllUsers.allUsers)
}
inline void AllUsers::add_allusers(absl::string_view value) {
  _internal_mutable_allusers()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csce438.AllUsers.allUsers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AllUsers::allusers() const {
  // @@protoc_insertion_point(field_list:csce438.AllUsers.allUsers)
  return _internal_allusers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AllUsers::mutable_allusers() {
  // @@protoc_insertion_point(field_mutable_list:csce438.AllUsers.allUsers)
  return _internal_mutable_allusers();
}
inline const std::string& AllUsers::_internal_allusers(int index) const {
  return _internal_allusers().Get(index);
}
inline std::string* AllUsers::_internal_add_allusers() {
  return _internal_mutable_allusers()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AllUsers::_internal_allusers() const {
  return _impl_.allusers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AllUsers::_internal_mutable_allusers() {
  return &_impl_.allusers_;
}

// -------------------------------------------------------------------

// GetFLRequest

// -------------------------------------------------------------------

// GetFLResponse

// repeated string lines = 1;
inline int GetFLResponse::_internal_lines_size() const {
  return _impl_.lines_.size();
}
inline int GetFLResponse::lines_size() const {
  return _internal_lines_size();
}
inline void GetFLResponse::clear_lines() {
  _internal_mutable_lines()->Clear();
}
inline std::string* GetFLResponse::add_lines() {
  std::string* _s = _internal_add_lines();
  // @@protoc_insertion_point(field_add_mutable:csce438.GetFLResponse.lines)
  return _s;
}
inline const std::string& GetFLResponse::lines(int index) const {
  // @@protoc_insertion_point(field_get:csce438.GetFLResponse.lines)
  return _internal_lines(index);
}
inline std::string* GetFLResponse::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:csce438.GetFLResponse.lines)
  return _internal_mutable_lines()->Mutable(index);
}
inline void GetFLResponse::set_lines(int index, const std::string& value) {
  _internal_mutable_lines()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::set_lines(int index, std::string&& value) {
  _internal_mutable_lines()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::set_lines(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_lines()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::set_lines(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_lines()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::set_lines(int index, absl::string_view value) {
  _internal_mutable_lines()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::add_lines(const std::string& value) {
  _internal_mutable_lines()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::add_lines(std::string&& value) {
  _internal_mutable_lines()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::add_lines(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_lines()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::add_lines(const char* value, std::size_t size) {
  _internal_mutable_lines()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csce438.GetFLResponse.lines)
}
inline void GetFLResponse::add_lines(absl::string_view value) {
  _internal_mutable_lines()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csce438.GetFLResponse.lines)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetFLResponse::lines() const {
  // @@protoc_insertion_point(field_list:csce438.GetFLResponse.lines)
  return _internal_lines();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* GetFLResponse::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:csce438.GetFLResponse.lines)
  return _internal_mutable_lines();
}
inline const std::string& GetFLResponse::_internal_lines(int index) const {
  return _internal_lines().Get(index);
}
inline std::string* GetFLResponse::_internal_add_lines() {
  return _internal_mutable_lines()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetFLResponse::_internal_lines() const {
  return _impl_.lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetFLResponse::_internal_mutable_lines() {
  return &_impl_.lines_;
}

// -------------------------------------------------------------------

// GetTLRequest

// int32 uid = 1;
inline void GetTLRequest::clear_uid() {
  _impl_.uid_ = 0;
}
inline ::int32_t GetTLRequest::uid() const {
  // @@protoc_insertion_point(field_get:csce438.GetTLRequest.uid)
  return _internal_uid();
}
inline void GetTLRequest::set_uid(::int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:csce438.GetTLRequest.uid)
}
inline ::int32_t GetTLRequest::_internal_uid() const {
  return _impl_.uid_;
}
inline void GetTLRequest::_internal_set_uid(::int32_t value) {
  ;
  _impl_.uid_ = value;
}

// -------------------------------------------------------------------

// GetTLResponse

// repeated string lines = 1;
inline int GetTLResponse::_internal_lines_size() const {
  return _impl_.lines_.size();
}
inline int GetTLResponse::lines_size() const {
  return _internal_lines_size();
}
inline void GetTLResponse::clear_lines() {
  _internal_mutable_lines()->Clear();
}
inline std::string* GetTLResponse::add_lines() {
  std::string* _s = _internal_add_lines();
  // @@protoc_insertion_point(field_add_mutable:csce438.GetTLResponse.lines)
  return _s;
}
inline const std::string& GetTLResponse::lines(int index) const {
  // @@protoc_insertion_point(field_get:csce438.GetTLResponse.lines)
  return _internal_lines(index);
}
inline std::string* GetTLResponse::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:csce438.GetTLResponse.lines)
  return _internal_mutable_lines()->Mutable(index);
}
inline void GetTLResponse::set_lines(int index, const std::string& value) {
  _internal_mutable_lines()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::set_lines(int index, std::string&& value) {
  _internal_mutable_lines()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::set_lines(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_lines()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::set_lines(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_lines()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::set_lines(int index, absl::string_view value) {
  _internal_mutable_lines()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::add_lines(const std::string& value) {
  _internal_mutable_lines()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::add_lines(std::string&& value) {
  _internal_mutable_lines()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::add_lines(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_lines()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::add_lines(const char* value, std::size_t size) {
  _internal_mutable_lines()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csce438.GetTLResponse.lines)
}
inline void GetTLResponse::add_lines(absl::string_view value) {
  _internal_mutable_lines()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csce438.GetTLResponse.lines)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetTLResponse::lines() const {
  // @@protoc_insertion_point(field_list:csce438.GetTLResponse.lines)
  return _internal_lines();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* GetTLResponse::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:csce438.GetTLResponse.lines)
  return _internal_mutable_lines();
}
inline const std::string& GetTLResponse::_internal_lines(int index) const {
  return _internal_lines().Get(index);
}
inline std::string* GetTLResponse::_internal_add_lines() {
  return _internal_mutable_lines()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetTLResponse::_internal_lines() const {
  return _impl_.lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetTLResponse::_internal_mutable_lines() {
  return &_impl_.lines_;
}

// -------------------------------------------------------------------

// ResynchServerRequest

// int32 serverID = 1;
inline void ResynchServerRequest::clear_serverid() {
  _impl_.serverid_ = 0;
}
inline ::int32_t ResynchServerRequest::serverid() const {
  // @@protoc_insertion_point(field_get:csce438.ResynchServerRequest.serverID)
  return _internal_serverid();
}
inline void ResynchServerRequest::set_serverid(::int32_t value) {
  _internal_set_serverid(value);
  // @@protoc_insertion_point(field_set:csce438.ResynchServerRequest.serverID)
}
inline ::int32_t ResynchServerRequest::_internal_serverid() const {
  return _impl_.serverid_;
}
inline void ResynchServerRequest::_internal_set_serverid(::int32_t value) {
  ;
  _impl_.serverid_ = value;
}

// -------------------------------------------------------------------

// ResynchServerResponse

// string Status = 1;
inline void ResynchServerResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ResynchServerResponse::status() const {
  // @@protoc_insertion_point(field_get:csce438.ResynchServerResponse.Status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResynchServerResponse::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:csce438.ResynchServerResponse.Status)
}
inline std::string* ResynchServerResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:csce438.ResynchServerResponse.Status)
  return _s;
}
inline const std::string& ResynchServerResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ResynchServerResponse::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ResynchServerResponse::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* ResynchServerResponse::release_status() {
  // @@protoc_insertion_point(field_release:csce438.ResynchServerResponse.Status)
  return _impl_.status_.Release();
}
inline void ResynchServerResponse::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csce438.ResynchServerResponse.Status)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace csce438


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_synchronizer_2eproto_2epb_2eh
